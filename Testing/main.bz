link "raylib"
link "gdi32"
link "winmm"

type color {
    byte r,
    byte g,
    byte b,
    byte a
}

type texture {
    i32 id,
    i32 width,
    i32 height,
    i32 mipmaps,
    i32 format
}

type rectangle {
    float x,
    float y,
    float width,
    float height
}

type vec2 {
    float x,
    float y
}

type cell {
    int number,
    bool closed,
    bool mine,
    bool flag,
}

cfn InitWindow(int w, int h, byte[] title)
cfn WindowShouldClose() bool
cfn BeginDrawing()
cfn EndDrawing()
cfn ClearBackground(color c)
cfn SetTargetFPS(int fps)

cfn LoadTexture(byte[] path) texture
cfn LoadImage(byte[] path) i32
cfn DrawTextureRec(texture t, rectangle r, vec2 pos, color c)
cfn DrawTexturePro(texture t, rectangle sr, rectangle dr, vec2 pos, float rot, color c)
cfn GetWorkingDirectory() void@
cfn InitAudioDevice()

cfn printf(byte[] fmt, *) i32
cfn time(int) int
cfn srand(int)
cfn rand() int
cfn tofloat(int) float

fn main() {
    call InitWindow(1600, 900, "Minesweeper")

    let color bg = color!{ 215, 215, 215, 255 }

    let texture closed = LoadTexture("assets/rescaled/closed.png")
    let texture mine = LoadTexture("assets/rescaled/mine.png")

    let texture opened = LoadTexture("assets/rescaled/opened.png")
    let texture _1 = LoadTexture("assets/rescaled/1.png")
    let texture _2 = LoadTexture("assets/rescaled/2.png")
    let texture _3 = LoadTexture("assets/rescaled/3.png")
    let texture _4 = LoadTexture("assets/rescaled/4.png")
    let texture _5 = LoadTexture("assets/rescaled/5.png")
    let texture _6 = LoadTexture("assets/rescaled/6.png")
    let texture _7 = LoadTexture("assets/rescaled/7.png")
    let texture _8 = LoadTexture("assets/rescaled/8.png")
    let texture[] numbers = [ opened, _1, _2, _3, _4, _5, _6, _7, _8 ]

    let rectangle tileSize = rectangle!{0,0,51,51}
    let vec2 offset = vec2!{0,0}
    let color tint = color!{255,255,255,255}
    let vec2 origin = vec2!{0,0}

    call srand(time(0))

    let int gridWidth = 30
    let int gridHeight = 16
    let cell[][] grid = *gridWidth
    for i from 0 until grid.len && {
        mut grid[i] = *gridHeight
        for j from 0 until grid[i].len && {
            let int r = rand() %% 100
            let bool isMine = r > 85
            mut grid[i][j] = cell!{0,true,isMine,false}
        }
    }

    for i from 0 until grid.len {
        for j from 0 until grid[i].len {
            let int around = 0

            for in from 0 until 3 {
                for jn from 0 until 3 {
                    if in == 1 { if jn == 1 { continue } }
                    let int id = i + in - 1
                    let int jd = j + jn - 1

                    if id < 0 continue
                    if id >= grid.len continue
                    if jd < 0 continue
                    if jd >= grid[i].len continue

                    if grid[id][jd].mine 
                        mut around = around + 1
                }
            }

            mut grid[i][j].number = around
        }
    }

    call SetTargetFPS(60)

    while !WindowShouldClose() {
        call BeginDrawing()

            call ClearBackground(bg)

            let cell[] e = grid[0]

            for i from 0 until gridWidth {
                for j from 0 until gridHeight {
                    let rectangle newR = rectangle!{tofloat(i*51), tofloat(j*51), 51, 51}
                    let cell c = grid[i][j]

                    if c.mine 
                        call DrawTexturePro(mine, tileSize, newR, origin, 0, tint)
                    else
                        call DrawTexturePro(numbers[c.number], tileSize, newR, origin, 0, tint)
                }
            }

        call EndDrawing()
    }
}
